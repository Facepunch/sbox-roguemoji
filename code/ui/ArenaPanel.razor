@using System;
@using Sandbox;
@using Sandbox.UI;
@using System.Collections.Generic;
@attribute [StyleSheet("/ui/Hud.scss")]

@inherits GridPanel;
@namespace Roguemoji

<style>
    .arena_panel
    {
        overflow: hidden;
    }

    .grid_bg 
    {
        opacity: 1;
        position:absolute;
        pointer-events:all;
        background-repeat: repeat;
        background-size: 80px;
        border-radius:3px;
        width:100%;
        height:100%;
    }

    .unseen
    {
        position: absolute;
        width: 40px;
        height: 40px;
        background-color: #050505;
        z-index: 9999;
    }

    .aiming 
    {
        position: absolute;
        width: 38px;
        height: 38px;
        z-index: 9998;
        pointer-events: none;
        border: 1px solid #ffff3311;
        border-radius:3px;
        color: #ffffff;
        justify-content: center;
        align-items: center;
        text-align: center;
        font-size: 25px;
    }
</style>

<root class="arena_panel">
    <div class="grid_bg" style="background-image: url( textures/bg_tile_green.png );" @ref=GridBg></div>
    
    @{
        var player = RoguemojiGame.Instance.LocalPlayer;
    }

    @if (RoguemojiGame.Instance.Levels[player.CurrentLevelId].GridManager?.Things == null)
    {
        return;
    }

    @foreach(Thing thing in GetThings())
    {
        if (player.IsGridPosOnCamera(thing.GridPos) && player.IsCellVisible(thing.GridPos))
        {
            var offsetGridPos = thing.GridPos - player.CameraGridOffset;
            var index = GetIndex(offsetGridPos);
            <GridCell style="left: @((offsetGridPos.x * 40) + player.CameraPixelOffset.x + thing.Offset.x * ScaleToScreen); top: @((offsetGridPos.y * 40) + player.CameraPixelOffset.y + thing.Offset.y * ScaleToScreen);" Thing=@thing GridIndex=@index />

            if (thing == player.SelectedThing)
            {
                <div class="selected" style="left: @((offsetGridPos.x * 40) + player.CameraPixelOffset.x + thing.Offset.x * ScaleToScreen); top: @((offsetGridPos.y * 40) + player.CameraPixelOffset.y + thing.Offset.y * ScaleToScreen);"></div>
            }
        }
    }

    @for(int x = -1; x <= RoguemojiGame.ArenaWidth; x++)
    {
        for(int y = -1; y <= RoguemojiGame.ArenaHeight; y++)
        {
            var gridPos = new IntVector(x, y) + player.CameraGridOffset;
            if(!player.IsCellVisible(gridPos))
            {
                <div class="unseen" style="left: @(x * 40 + player.CameraPixelOffset.x); top: @(y * 40 + player.CameraPixelOffset.y);"></div>
            }
            else if(player.IsAiming && player.AimingCells.Contains(gridPos))
            {
                var aimOpacity = 0.5f + MathF.Sin(Time.Now * 16f) * 0.25f;
                var dir = GridManager.GetDirectionForIntVector(gridPos - player.GridPos);
                <div class="aiming" style="left: @(x * 40 + player.CameraPixelOffset.x + 1); top: @(y * 40 + player.CameraPixelOffset.y + 1); opacity: @(aimOpacity); padding-bottom: @(GetAimingPadding(dir));">@GetArrowIcon(dir)</div>
            }
        }
    }
</root>

@code
{
    public Panel GridBg { get; protected set; }

    public override int GridWidth => RoguemojiGame.ArenaWidth;
    public override int GridHeight => RoguemojiGame.ArenaHeight;

    string GetArrowIcon(Direction direction)
    {
        switch (direction)
        {
            case Direction.Left: return "👈️";
            case Direction.Right: return "👉️";
            case Direction.Down: return "👇️";
            case Direction.Up: return "👆️";
        }

        return "";
    }

    int GetAimingPadding(Direction direction)
    {
        switch (direction)
        {
            case Direction.Left: return 9;
            case Direction.Right: return 9;
            case Direction.Down: return 2;
            case Direction.Up: return 2;
        }

        return 0;
    }

    protected override IList<Thing> GetThings()
    {
        var player = RoguemojiGame.Instance.LocalPlayer;
        return RoguemojiGame.Instance.Levels[player.CurrentLevelId].GridManager?.Things ?? new List<Thing>();
    }

    public override void Tick()
    {
        base.Tick();

        StateHasChanged();

        //var player = RoguemojiGame.Instance.LocalPlayer;
        //foreach(var gridPos in player.VisibleCells)
        //{
        //    Hud.Instance.MainPanel.DebugDrawing.GridCell(gridPos, new Color(0f, 0f, 1f, 0.1f));
        //}
        //Hud.Instance.MainPanel.DebugDrawing.Line(new Vector2(100f, 100f), new Vector2(200f, 85f), new Color(0f, 1f, 0f, 0.5f));
        //Hud.Instance.MainPanel.DebugDrawing.GridLine(new IntVector(10, 10), new IntVector(15, 15), Color.Blue);
        //Hud.Instance.MainPanel.DebugDrawing.GridCell(new IntVector(9, 10), Color.Red);
    }

    protected override void OnMouseDown(MousePanelEvent e)
    {
        base.OnMouseDown(e);

        var player = RoguemojiGame.Instance.LocalPlayer;
        var gridPos = GetGridPos(MousePosition) + player.CameraGridOffset;
        bool visible = player.IsCellVisible(gridPos);

        if (player.ContainingGridManager.IsGridPosInBounds(gridPos))
        {
            if(player.IsAiming && player.AimingCells.Contains(gridPos))
                RoguemojiGame.ConfirmAimingCmd(gridPos.x, gridPos.y);
            else 
                Hud.Instance.GridCellClicked(gridPos, GridType.Arena, rightClick: e.Button == "mouseright", shift: Input.Down(InputButton.Run), doubleClick: false, visible);
        }
    }

    //protected override int BuildHash()
    //{
    //    var player = RoguemojiGame.Instance.LocalPlayer;
    //    return HashCode.Combine(GetThings().Count, player.CameraGridOffset, player.CameraPixelOffset);
    //}

    protected override void OnAfterTreeRender(bool firstTime)
    {
        base.OnAfterTreeRender(firstTime);

        var player = RoguemojiGame.Instance.LocalPlayer;
        GridBg.Style.Set($"background-position: {((player.CameraGridOffset.x % 2 == 0 ? -40f : -80f) + player.CameraPixelOffset.x * 0.9f) * ScaleToScreen}px {((player.CameraGridOffset.y % 2 == 0 ? -40f : -80f) + player.CameraPixelOffset.y * 0.9f) * ScaleToScreen}px;");
    }

    bool IsOdd(IntVector gridPos)
    {
        return gridPos.x % 2 == gridPos.y % 2;
    }
}