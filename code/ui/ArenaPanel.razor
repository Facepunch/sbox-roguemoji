@using System;
@using Sandbox;
@using Sandbox.UI;
@using System.Collections.Generic;
@attribute [StyleSheet("/ui/Hud.scss")]

@inherits GridPanel;
@namespace Roguemoji

<style>
    .arena_panel {
        overflow: hidden;
        //justify-content: center;
        //border: 1px solid #202020;
        border-radius: 3px;
        height: 100%;
    }

    .level_label {
        position: absolute;
        left: 2px;
        top: 2px;
        transition: opacity 0.4s ease-out;
        font-size: 15px;
        padding: 5px;
        border: 1px solid #ffffff33;
        border-radius: 3px;
        background-color: #000000;
        color: #ffffffbb;
        justify-content: center;
        align-items: center;
        text-align: center;
        z-index: 20003;
        pointer-events: none;
    }

    .grid_bg {
        opacity: 1;
        position:absolute;
        pointer-events:all;
        background-repeat: repeat;
        background-size: 84px;
        border-radius:3px;
        width:100%;
        height:100%;
    }

    .unseen {
        position: absolute;
        width: 42px;
        height: 42px;
        background-color: #050505;
        z-index: 9999;
    }

    .greyed_out {
        position: absolute;
        width: 42px;
        height: 42px;
        z-index: 9999;
        filter: brightness(30%);
    }

    .seen_icon
    {
        position: absolute;
        width: 42px;
        height: 42px;
        filter: brightness(30%);
        justify-content: center;
        align-items: center;
        text-align: center;
        font-size: 29px;
        padding-bottom: 4px;
        border: 1px solid #00000000;
        filter: brightness(10%);
        font-family: W10Emoji;
    }

    .seen_tattoo {
        width: 100%;
        height: 100%;
        position: absolute;
        justify-content: center;
        align-items: center;
        text-stroke-color: #000000;
        text-stroke-width: 1px;
    }

    .seen_wielded {
        width: 21px;
        height: 21px;
        position: absolute;
        pointer-events: none;
        text-stroke-color: #000000;
        text-stroke-width: 2px;
        text-shadow: 0px 0px 0px #000000;
    }

    .aiming {
        position: absolute;
        width: 40px;
        height: 40px;
        z-index: 9998;
        pointer-events: none;
        border: 1px solid #ffff3311;
        border-radius:3px;
        color: #ffffff;
        justify-content: center;
        align-items: center;
        text-align: center;
        font-size: 25px;
        padding-bottom: 2px;
    }

    .aiming_pin {
        color: white;
        font-size: 29px;
        z-index: 10001;
    }

    .arena_fade {
        width: 100%;
        height: 100%;
        position: absolute;
        background-color: #050505;
        z-index: 20002;
    }
</style>

<root class="arena_panel">
    <div class="grid_bg" style="background-image: url( textures/bg_tile_green.png );" @ref=GridBg></div>
    
    @{
        var player = RoguemojiGame.Instance.LocalPlayer;
        var level = RoguemojiGame.Instance.GetLevel(player.CurrentLevelId);
    }

    @if (level?.GridManager?.Things == null)
    {
        return;
    }

    @foreach(Thing thing in GetThings())
    {
        var canSeeThing = player.IsGridPosOnCamera(thing.GridPos) && player.IsCellVisible(thing.GridPos) && player.CanSeeThing(thing);

        if ((canSeeThing || thing.TimeSinceLocalPlayerSaw < 0.25f) && !thing.DontRender)
        {
            var offsetGridPos = thing.GridPos - player.CameraGridOffset;
            var index = GetIndex(offsetGridPos);

            if (thing == player.SelectedThing)
            {
                <div class="selected" style="left: @((offsetGridPos.x * RoguemojiGame.CellSize) + player.CameraPixelOffset.x + thing.TotalOffset.x * ScaleToScreen); top: @((offsetGridPos.y * RoguemojiGame.CellSize) + player.CameraPixelOffset.y + thing.TotalOffset.y * ScaleToScreen);"></div>
            }

            <GridCell style="left: @((offsetGridPos.x * RoguemojiGame.CellSize) + player.CameraPixelOffset.x + thing.TotalOffset.x * ScaleToScreen); top: @((offsetGridPos.y * RoguemojiGame.CellSize) + player.CameraPixelOffset.y + thing.TotalOffset.y * ScaleToScreen);" Thing=@thing GridIndex=@index />
        }

        if (canSeeThing)
            thing.TimeSinceLocalPlayerSaw = 0f;
    }

    @for(int x = -1; x <= RoguemojiGame.ArenaPanelWidth; x++)
    {
        for(int y = -1; y <= RoguemojiGame.ArenaPanelHeight; y++)
        {
            var gridPos = new IntVector(x, y) + player.CameraGridOffset;
            if(!player.IsCellVisible(gridPos))
            {
                if(player.IsCellSeen(gridPos))
                {
                    <div class="greyed_out" style="left: @(x * RoguemojiGame.CellSize + player.CameraPixelOffset.x); top: @(y * RoguemojiGame.CellSize + player.CameraPixelOffset.y); background-color:@(player.ContainingGridManager.GetNearbyBgColor(gridPos));"></div>

                    @foreach(var seenData in player.GetSeenThings(gridPos))
                    {
                        <div class="seen_icon @(seenData.isSolid ? "solid" : "") @(seenData.playerNum > 0 ? $"icon-player-{seenData.playerNum}" : "")" style="left: @(x * RoguemojiGame.CellSize + player.CameraPixelOffset.x); top: @(y * RoguemojiGame.CellSize + player.CameraPixelOffset.y); z-index:@(9999 + level.GridManager.GetIndex(gridPos) + seenData.zIndex);">
                            @(Hud.GetHallucinationTextStr(seenData.icon, HallucinationTextType.Icon))

                            @if (seenData.tattooData != null)
                            {
                                int fontSize = MathX.FloorToInt(29f * seenData.tattooData.Scale);
                                var offset = seenData.tattooData.Offset;
                                <div class="seen_tattoo" style="font-size: @(fontSize)px; left: @(offset.x - 1)px; top: @(offset.y - 4)px;">
                                    @(seenData.tattooData.Icon)
                                </div>
                            }

                            @if (seenData.hasWieldedThing)
                            {
                                var wieldedOffset = seenData.wieldedThingOffset;
                                <div class="seen_wielded" style="left:@(wieldedOffset.x)px; top:@(wieldedOffset.y)px; font-size:@(seenData.wieldedThingFontSize);">
                                    @(Hud.GetHallucinationTextStr(seenData.wieldedThingIcon, HallucinationTextType.Icon))

                                    @if (seenData.wieldedThingTattooData != null)
                                    {
                                        int fontSize = MathX.FloorToInt(18f * seenData.wieldedThingTattooData.Scale);
                                        var offset = seenData.wieldedThingTattooData.OffsetWielded;
                                        <div class="seen_tattoo" style="font-size: @(fontSize)px; left: @(offset.x)px; top: @(offset.y)px;">
                                            @(seenData.wieldedThingTattooData.Icon)
                                        </div>
                                    }
                                </div>
                            }
                        </div>
                    }
                }
                else
                {
                    <div class="unseen" style="left: @(x * RoguemojiGame.CellSize + player.CameraPixelOffset.x); top: @(y * RoguemojiGame.CellSize + player.CameraPixelOffset.y);"></div>
                }
            }
            else if(player.IsAiming && player.AimingCells.Contains(gridPos))
            {
                var aimOpacity = 0.4f + MathF.Sin(Time.Now * 16f) * 0.3f;
                var dir = GridManager.GetDirectionForIntVector(gridPos - player.GridPos);
                <div class="aiming" style="left: @(x * RoguemojiGame.CellSize + player.CameraPixelOffset.x + 1); top: @(y * RoguemojiGame.CellSize + player.CameraPixelOffset.y + 1); opacity: @(aimOpacity); transform: rotate(@(GetAimingAngle(dir)));">
                    @if(player.AimingType == AimingType.Direction)
                        @(GetArrowIcon(dir))
                </div>

                @if(player.AimingType == AimingType.TargetCell)
                {
                    var arenaPanel = Hud.Instance.GetGridPanel(GridType.Arena);
                    var mouseGridPos = arenaPanel.GetGridPos(arenaPanel.MousePosition) + player.CameraGridOffset;

                    if(gridPos.Equals(mouseGridPos))
                    {
                        <div class="aiming_pin" style="left: @((x * RoguemojiGame.CellSize) + player.CameraPixelOffset.x + 9); top: @((y * RoguemojiGame.CellSize) + player.CameraPixelOffset.y - 13);">
                            @(Hud.GetHallucinationTextStr("📍", HallucinationTextType.Icon))
                        </div>
                    }
                }
            }
        }
    }

    @if(player.CameraFade > 0f)
    {
        <div class="arena_fade" style="opacity:@(player.CameraFade);"></div>
    }

    <div class="level_label" style="opacity:@(LevelLabelOpacity);" @ref=LevelLabel>
        @(Hud.GetConfusedText(level.LevelName))
    </div>
</root>

@code
{
    public Panel GridBg { get; protected set; }
    public Panel LevelLabel { get; protected set; }
    public float LevelLabelOpacity { get; set; }

    public override int GridWidth => RoguemojiGame.ArenaPanelWidth;
    public override int GridHeight => RoguemojiGame.ArenaPanelHeight;
    string GetArrowIcon(Direction direction)
    {
        if (direction != Direction.None)
            return "🔼";
        else
            return "";
    }

    int GetAimingAngle(Direction direction)
    {
        switch (direction)
        {
            case Direction.Left: return -90;
            case Direction.Right: return 90;
            case Direction.Down: return 180;
            case Direction.Up: return 0;
        }

        return 0;
    }

    protected override IList<Thing> GetThings()
    {
        var player = RoguemojiGame.Instance.LocalPlayer;
        return RoguemojiGame.Instance.GetLevel(player.CurrentLevelId).GridManager?.Things ?? new List<Thing>();
    }

    public override void Tick()
    {
        base.Tick();

        StateHasChanged();

        var hoveringLevelLabel = Hud.Instance.GetContainingPanelType(Hud.Instance.MousePosition) == PanelType.LevelLabel;
        LevelLabelOpacity = hoveringLevelLabel ? 0f : 0.9f;
    }

    protected override void OnMouseDown(MousePanelEvent e)
    {
        base.OnMouseDown(e);

        var player = RoguemojiGame.Instance.LocalPlayer;
        var gridPos = GetGridPos(MousePosition) + player.CameraGridOffset;
        bool visible = player.IsCellVisible(gridPos);

        if (player.ContainingGridManager.IsGridPosInBounds(gridPos))
        {
            if(player.IsAiming && player.AimingCells.Contains(gridPos) && visible)
                RoguemojiGame.ConfirmAimingCmd(gridPos.x, gridPos.y);
            else 
                Hud.Instance.GridCellClicked(gridPos, GridType.Arena, rightClick: e.Button == "mouseright", shift: Input.Down(InputButton.Run), doubleClick: false, visible);
        }

        Hud.Instance.UnfocusChatbox();
    }

    protected override void OnAfterTreeRender(bool firstTime)
    {
        base.OnAfterTreeRender(firstTime);

        var player = RoguemojiGame.Instance.LocalPlayer;
        GridBg.Style.Set($"background-position: {((player.CameraGridOffset.x % 2 == 0 ? -RoguemojiGame.CellSize : -RoguemojiGame.CellSize * 2) + player.CameraPixelOffset.x * 0.9f) * ScaleToScreen}px {((player.CameraGridOffset.y % 2 == 0 ? -RoguemojiGame.CellSize : -RoguemojiGame.CellSize * 2) + player.CameraPixelOffset.y * 0.9f) * ScaleToScreen}px;");
    }
}